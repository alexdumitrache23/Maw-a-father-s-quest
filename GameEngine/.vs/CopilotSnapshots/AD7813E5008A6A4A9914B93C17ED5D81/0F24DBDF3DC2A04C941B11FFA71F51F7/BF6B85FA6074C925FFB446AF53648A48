#include "Graphics\window.h"
#include "Camera\camera.h"
#include "Shaders\shader.h"
#include "Model Loading\mesh.h"
#include "Model Loading\texture.h"
#include "Model Loading\meshLoaderObj.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <glew.h>
#include <glfw3.h>
#include <glm.hpp>
#include <gtc/matrix_transform.hpp>

#include "Dependencies/imgui/imgui.h"
#include "Dependencies/imgui/imgui_impl_glfw.h"
#include "Dependencies/imgui/imgui_impl_opengl3.h"


struct GameObject
{
	glm::vec3 pos;
	glm::vec3 scale;
	float yaw = 0.0f;
	float pitch = 0.0f;
	float roll = 0.0f;
	glm::vec3 velocity;
	float health = 100.0f;
	bool active = false;
	bool attacking = false;
	float attackTimer = 0.0f;
	float attackCooldown = 0.0f;
	int type = 0;
	bool isHeld = false;
};

enum GameState { MENU, STORY_SCREEN, SEWERS, STREET, MEN_LASAGNA, KEY_PUZZLE, BOSS_RESCUE, GAME_OVER };

float deltaTime = 0.0f;
float lastFrame = 0.0f;
Window window("Maw: A Father's Quest", 1024, 768);
Camera camera;


float dayCycleTimer = 0.0f;
const float dayDuration = 60.0f;
glm::vec3 sunPos;
glm::vec3 sunColor;
bool firstPersonView = false;


float camYaw = 90.0f;
float camPitch = -10.0f;

bool checkCollision(const GameObject& a, const GameObject& b)
{
	if (!a.active || !b.active) return false;
	const float wallPadding = 0.5f;

	float a_half_x = a.scale.x * 0.5f;
	float a_half_z = a.scale.z * 0.5f;
	float b_half_x = b.scale.x * 0.5f;
	float b_half_z = b.scale.z * 0.5f;
	if (a.type == 10 || b.type == 10) {
		a_half_x += wallPadding;
		a_half_z += wallPadding;
		b_half_x += wallPadding;
		b_half_z += wallPadding;
	}
	return (std::abs(a.pos.x - b.pos.x) < (a_half_x + b_half_x)) &&
		(std::abs(a.pos.z - b.pos.z) < (a_half_z + b_half_z));
}

void resolveOverlap(GameObject& a, GameObject& b)
{
	if (!a.active || !b.active || !checkCollision(a, b)) return;

	const bool aIsWall = (a.type == 10);
	const bool bIsWall = (b.type == 10);
	const float wallPadding = 0.5f;

	float a_half_x = a.scale.x * 0.5f;
	float a_half_z = a.scale.z * 0.5f;
	float b_half_x = b.scale.x * 0.5f;
	float b_half_z = b.scale.z * 0.5f;
	if (aIsWall || bIsWall) {
		a_half_x += wallPadding; b_half_x += wallPadding;
		a_half_z += wallPadding; b_half_z += wallPadding;
	}

	float dx = a.pos.x - b.pos.x;
	float dz = a.pos.z - b.pos.z;
	float overlapX = (a_half_x + b_half_x) - std::abs(dx);
	float overlapZ = (a_half_z + b_half_z) - std::abs(dz);

	if (overlapX <= 0.0f && overlapZ <= 0.0f) return;

	if (overlapX < overlapZ) {
		float sign = (dx >= 0.0f) ? 1.0f : -1.0f;
		float move = overlapX + 0.001f;
		if (aIsWall && !bIsWall) b.pos.x -= sign * move;
		else if (bIsWall && !aIsWall) a.pos.x += sign * move;
		else {
			if (a.type == 0) b.pos.x -= sign * move;
			else if (b.type == 0) a.pos.x += sign * move;
			else { a.pos.x += sign * move * 0.5f; b.pos.x -= sign * move * 0.5f; }
		}
	}
	else {
		float sign = (dz >= 0.0f) ? 1.0f : -1.0f;
		float move = overlapZ + 0.001f;
		if (aIsWall && !bIsWall) b.pos.z -= sign * move;
		else if (bIsWall && !aIsWall) a.pos.z += sign * move;
		else {
			if (a.type == 0) b.pos.z -= sign * move;
			else if (b.type == 0) a.pos.z += sign * move;
			else { a.pos.z += sign * move * 0.5f; b.pos.z -= sign * move * 0.5f; }
		}
	}
}

int main()
{
	glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO(); (void)io;
	ImGui::StyleColorsDark();
	ImGui_ImplGlfw_InitForOpenGL(window.getWindow(), true);
	ImGui_ImplOpenGL3_Init("#version 400");

	Shader shader("Shaders/vertex_shader.glsl", "Shaders/fragment_shader.glsl");

	MeshLoaderObj loader;


	Texture t_wood; t_wood.id = loadBMP("Resources/Textures/wood.bmp"); t_wood.type = "texture_diffuse";
	Texture t_rock; t_rock.id = loadBMP("Resources/Textures/rock.bmp"); t_rock.type = "texture_diffuse";
	Texture t_orange; t_orange.id = loadBMP("Resources/Textures/orange.bmp"); t_orange.type = "texture_diffuse";

	Texture t_rat; t_rat.id = loadBMP("Resources/Textures/mouse.bmp"); t_rat.type = "texture_diffuse";
	Texture t_cat; t_cat.id = loadBMP("Resources/Textures/cat_color.bmp"); t_cat.type = "texture_diffuse";
	Texture t_green_attack; t_green_attack.id = loadBMP("Resources/Textures/green_attack.bmp"); t_green_attack.type = "texture_diffuse";
	Texture t_cat_attack; t_cat_attack.id = loadBMP("Resources/Textures/cat_attack_texture.bmp"); t_cat_attack.type = "texture_diffuse";
	Texture t_sewer_walls; t_sewer_walls.id = loadBMP("Resources/Textures/sewer_walls.bmp"); t_sewer_walls.type = "texture_diffuse";
	Texture t_sewer_door; t_sewer_door.id = loadBMP("Resources/Textures/sewer_door.bmp"); t_sewer_door.type = "texture_diffuse";
	Texture t_asphalt; t_asphalt.id = loadBMP("Resources/Textures/Asphalt.bmp"); t_asphalt.type = "texture_diffuse";
	Texture t_car; t_car.id = loadBMP("Resources/Textures/car.bmp"); t_car.type = "texture_diffuse";


	std::vector<Texture> texWood = { t_wood };
	std::vector<Texture> texRock = { t_rock };
	std::vector<Texture> texOrange = { t_orange };
	std::vector<Texture> texRat = { t_rat };
	std::vector<Texture> texCat = { t_cat };
	std::vector<Texture> texDoor = { t_sewer_door };
	std::vector<Texture> texCar = { t_car };
	std::vector<Texture> texAsphalt = { t_asphalt };
	std::vector<Texture> texBuilding = { t_sewer_walls };


	Mesh sphere = loader.loadObj("Resources/Models/sphere.obj", texOrange);
	Mesh cube = loader.loadObj("Resources/Models/cube.obj", texWood);
	Mesh terrain = loader.loadObj("Resources/Models/plane1.obj", texRock);

	Mesh water = loader.loadObj("Resources/Models/plane1.obj", texRock);
	Mesh ratMesh = loader.loadObj("Resources/Models/rat.obj", texRat);
	Mesh greenSphere = loader.loadObj("Resources/Models/sphere.obj", { t_green_attack });
	Mesh furBall = loader.loadObj("Resources/Models/fur_ball.obj", { t_cat_attack });
	Mesh catMesh = loader.loadObj("Resources/Models/cat.obj", texCat);

	Mesh sewerWall = loader.loadObj("Resources/Models/sewer_wall.obj", { t_sewer_walls });
	Mesh sewerDoorMesh = loader.loadObj("Resources/Models/sewer_door.obj", texDoor);

	Mesh streetGroundMesh = loader.loadObj("Resources/Models/plane1.obj", texRock);
	Mesh carMesh = loader.loadObj("Resources/Models/car.obj", texCar);

	Mesh lasagnaMesh = loader.loadObj("Resources/Models/lasagna.obj", texOrange);
	Mesh bossMesh = loader.loadObj("Resources/Models/boss.obj", texRat);
	Mesh keyMesh = loader.loadObj("Resources/Models/key.obj", texOrange);
	Mesh boxMesh = loader.loadObj("Resources/Models/storage_box.obj", texWood);

	GameState state = MENU;

	GameObject player;
	player.pos = glm::vec3(0.0f, -20.0f, 0.0f);
	player.scale = glm::vec3(1.0f);
	player.health = 100.0f;
	player.active = true;
	player.type = 0;
	player.isHeld = false;

	float catShootCooldown = 1.2f;
	float catShootTimer = catShootCooldown;
	float playerYaw = 10.0f;

	std::vector<GameObject> enemies;
	std::vector<GameObject> projectiles;
	std::vector<GameObject> furProjectiles;
	std::vector<GameObject> sewerWalls;
	std::vector<GameObject> obstacles;
	std::vector<GameObject> items;
	std::vector<GameObject> scenery;
	GameObject exitDoor;
	GameObject buildingATarget;

	// Sewers
	{
		const float sideOffset = 15.0f;
		const int segments = 16;
		const float segmentSpacing = 7.0f;
		const float y = 0.0f;
		const float zStart = player.pos.z;
		glm::vec3 wallScale = glm::vec3(6.0f, 20.0f, 6.0f) / 50.0f;
		for (int i = 0; i < segments; ++i) {
			float z = zStart - i * segmentSpacing;
			GameObject wl; wl.pos = glm::vec3(player.pos.x - sideOffset, y, z); wl.scale = wallScale; wl.active = true; wl.type = 10; wl.yaw = 5500.0f;
			GameObject wr; wr.pos = glm::vec3(player.pos.x + sideOffset, y, z); wr.scale = wallScale; wr.active = true; wr.type = 10; wr.yaw = 5500.0f;
			sewerWalls.push_back(wl); sewerWalls.push_back(wr);
		}
		GameObject backW; backW.pos = glm::vec3(player.pos.x, 2.0f, zStart + 50.0f); backW.scale = glm::vec3(15.0f, 15.0f, 1.0f) / 5.0f; backW.yaw = 0.0f; backW.type = 10; backW.active = true;
		sewerWalls.push_back(backW);

		exitDoor.pos = glm::vec3(player.pos.x, 2.5f, zStart - (segments * segmentSpacing) - 5.0f);
		exitDoor.scale = glm::vec3(0.5f);
		exitDoor.active = false;
		exitDoor.type = 11;
		exitDoor.yaw = 0.0f;
		exitDoor.pitch = glm::degrees(90.0f);
	}

	auto spawnRat = [&](glm::vec3 p) {
		const float corridorHalfWidth = 15.0f - 2.0f;
		GameObject g; g.scale = glm::vec3(2.5f); g.health = 40.0f; g.active = true; g.attacking = false; g.attackCooldown = 1.0f; g.attackTimer = 1.0f; g.type = 1;
		bool placed = false;
		for (int a = 0; a < 30; ++a) {

			float rx = ((rand() % 1000) / 1000.0f) * 2.0f - 1.0f;
			float rz = ((rand() % 1000) / 1000.0f) * 2.0f - 1.0f;
			glm::vec3 candidate = glm::vec3(p.x + rx, p.y, p.z + rz);

			if (state == SEWERS) candidate.x = glm::clamp(candidate.x, player.pos.x - corridorHalfWidth, player.pos.x + corridorHalfWidth);
			g.pos = candidate;

			bool coll = false;
			for (auto& ex : enemies) if (checkCollision(g, ex)) { coll = true; break; }
			if (!coll) { placed = true; break; }
		}
		if (!placed) g.pos = p;
		enemies.push_back(g);
		};

	auto spawnProjectile = [&](const glm::vec3& pos, const glm::vec3& vel) {
		GameObject p; p.pos = pos; p.velocity = vel; p.scale = glm::vec3(0.002f); p.active = true; p.attacking = false; p.attackTimer = 3.0f; p.type = 8;
		projectiles.push_back(p);
		};
	auto spawnCar = [&](glm::vec3 p) {
		GameObject g; g.pos = p; g.scale = glm::vec3(2.5f);
		g.velocity = glm::vec3(0.0f, 0.0f, 15.0f);
		g.active = true; g.type = 4;
		obstacles.push_back(g);
		};
	auto spawnMan = [&](glm::vec3 p) {
		GameObject g; g.pos = p; g.scale = glm::vec3(1.0f, 2.0f, 1.0f); g.health = 50.0f; g.active = true; g.type = 2;
		enemies.push_back(g);
		};
	auto spawnBoss = [&](glm::vec3 p) {
		GameObject g; g.pos = p; g.scale = glm::vec3(3.0f); g.health = 200.0f; g.active = true; g.type = 3;
		enemies.push_back(g);
		};


	bool ratsSpawned = false;
	float ratsSpawnTimer = 0.0f;
	bool playerMoved = false;

	std::vector<int> ratWaves = { 3, 4, 3 };
	int currentWaveIndex = 0;
	float waveTimer = 0.0f;
	const float waveInterval = 3.0f;

	const int totalRatsToSpawn = 10;
	int totalSpawned = 0;
	bool sewerLevelComplete = false;

	glEnable(GL_DEPTH_TEST);

	while (!window.isPressed(GLFW_KEY_ESCAPE) && glfwWindowShouldClose(window.getWindow()) == 0)
	{
		window.clear();
		float currentFrame = glfwGetTime();
		deltaTime = currentFrame - lastFrame;
		lastFrame = currentFrame;


		ImGui_ImplOpenGL3_NewFrame();
		ImGui_ImplGlfw_NewFrame();
		ImGui::NewFrame();

		if (state == MENU) {
			ImGui::SetNextWindowPos(ImVec2(0, 0));
			ImGui::SetNextWindowSize(io.DisplaySize);
			ImGui::Begin("Menu", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoBackground);
			ImGui::SetWindowFontScale(3.0f);
			auto titleText = "Maw: A Father's Quest";
			auto titleWidth = ImGui::CalcTextSize(titleText).x;
			ImGui::SetCursorPosX((io.DisplaySize.x - titleWidth) * 0.5f);
			ImGui::SetCursorPosY(io.DisplaySize.y * 0.35f);
			ImGui::TextColored(ImVec4(1, 1, 0, 1), titleText);
			ImGui::SetCursorPosX((io.DisplaySize.x - 250) * 0.5f);
			ImGui::SetCursorPosY(io.DisplaySize.y * 0.55f);
			if (ImGui::Button("PLAY", ImVec2(250, 80))) state = STORY_SCREEN;
			ImGui::End();
		}
		else if (state == STORY_SCREEN) {
			ImVec2 winSize = ImVec2(io.DisplaySize.x * 0.8f, io.DisplaySize.y * 0.8f);
			ImGui::SetNextWindowSize(winSize);
			ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
			ImGui::Begin("Story", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoBackground);
			ImGui::SetWindowFontScale(2.0f);
			ImGui::TextWrapped("Maw was a stray cat which had a little kitten named Pippin.\n\nWhile they were hanging out at the back door of an italian restaurant where they were plotting to steal some lasagna, the cat catchers ambushed them.\n\nMaw managed to flee, but his kitten was captured by the bad guys and taken to the animal center.\n\nWhile running Maw falls down in a sewer.\n\nHe goes in the adventure to save his kitten.");
			ImGui::Dummy(ImVec2(0.0f, 50.0f));
			ImGui::SetCursorPosX((winSize.x - 250) * 0.5f);
			if (ImGui::Button("Start Adventure", ImVec2(250, 60))) state = SEWERS;
			ImGui::End();
		}
		else if (state == GAME_OVER) {
			ImGui::SetNextWindowPos(ImVec2(0, 0));
			ImGui::SetNextWindowSize(io.DisplaySize);
			ImGui::Begin("GameOver", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoBackground);
			ImGui::SetWindowFontScale(4.0f);
			auto failText = "You failed!";
			auto failWidth = ImGui::CalcTextSize(failText).x;
			ImGui::SetCursorPosX((io.DisplaySize.x - failWidth) * 0.5f);
			ImGui::SetCursorPosY(io.DisplaySize.y * 0.4f);
			ImGui::TextColored(ImVec4(1, 0, 0, 1), failText);
			ImGui::SetWindowFontScale(2.0f);
			ImGui::SetCursorPosX((io.DisplaySize.x - 200) * 0.5f);
			ImGui::SetCursorPosY(io.DisplaySize.y * 0.6f);
			if (ImGui::Button("Restart", ImVec2(200, 60))) {
				player.health = 100.0f;
				player.pos = glm::vec3(0.0f, 0.5f, 0.0f);
				state = SEWERS;
				enemies.clear(); projectiles.clear(); items.clear(); obstacles.clear(); scenery.clear();
				ratsSpawned = false; totalSpawned = 0; currentWaveIndex = 0; waveTimer = 0.0f; playerMoved = false; sewerLevelComplete = false; exitDoor.active = false;
			}
			ImGui::End();
		}
		else {
			ImGui::SetNextWindowPos(ImVec2(20, 20));
			ImGui::Begin("HUD", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoBackground);
			ImGui::SetWindowFontScale(1.5f);
			ImGui::Text("Health: %.0f / 100", player.health);
			ImGui::ProgressBar(player.health / 100.0f, ImVec2(300.0f, 30.0f));
			if (ImGui::Button(firstPersonView ? "View: First-Person" : "View: First-person", ImVec2(220, 40))) firstPersonView = !firstPersonView;
			ImGui::Separator();

			if (state == SEWERS) {
				if (sewerLevelComplete) ImGui::Text("SEWERS CLEAR! Find Exit Door & Press 'F'");
				else if (!ratsSpawned) ImGui::Text("Task: Escape the Sewer");
				else ImGui::Text("Task: Defeat 10 Rats (%d/10)", totalSpawned);
			}
			else if (state == STREET) ImGui::Text("Task: Avoid Cars & Enter Building A");
			else if (state == MEN_LASAGNA) ImGui::Text("Task: Defeat Guards & Eat Lasagna");
			else if (state == KEY_PUZZLE) ImGui::Text("Task: Navigate Maze, Find Key & Press 'F'");
			else if (state == BOSS_RESCUE) ImGui::Text("Task: Defeat Boss & Save Pippin!");
			ImGui::End();
		}

		if (state != MENU && state != STORY_SCREEN && state != GAME_OVER) {

			if (player.health <= 0.0f) state = GAME_OVER;


			if (state == STREET) {
				dayCycleTimer += deltaTime;
				if (dayCycleTimer > dayDuration) dayCycleTimer -= dayDuration;
				float angle = (dayCycleTimer / dayDuration) * 2.0f * PI;
				sunPos.x = sin(angle) * 60.0f; sunPos.y = cos(angle) * 60.0f; sunPos.z = 0.0f;
				if (sunPos.y > 20.0f) { sunColor = glm::vec3(1.0f, 1.0f, 0.9f); glClearColor(0.5f, 0.7f, 0.9f, 1.0f); }
				else if (sunPos.y > 0.0f) { sunColor = glm::vec3(1.0f, 0.5f, 0.2f); glClearColor(0.8f, 0.4f, 0.2f, 1.0f); }
				else { sunColor = glm::vec3(0.1f, 0.1f, 0.3f); glClearColor(0.0f, 0.0f, 0.1f, 1.0f); }
			}
			else if (state == SEWERS) {
				sunPos = player.pos + glm::vec3(0.0f, 1.0f, 0.0f);
				sunColor = glm::vec3(0.6f, 0.7f, 0.4f);
				glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
			}
			else {
				sunPos = glm::vec3(0.0f, 50.0f, 0.0f);
				sunColor = glm::vec3(1.0f, 1.0f, 1.0f);
				glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
			}


			float speed = 10.0f * deltaTime;
			if (window.isPressed(GLFW_KEY_W)) player.pos.z -= speed;
			if (window.isPressed(GLFW_KEY_S)) player.pos.z += speed;
			if (window.isPressed(GLFW_KEY_A)) player.pos.x -= speed;
			if (window.isPressed(GLFW_KEY_D)) player.pos.x += speed;

			if (!playerMoved && (window.isPressed(GLFW_KEY_W) || window.isPressed(GLFW_KEY_A) || window.isPressed(GLFW_KEY_S) || window.isPressed(GLFW_KEY_D))) playerMoved = true;
			if (window.isPressed(GLFW_KEY_Q)) playerYaw += 5000.0f * deltaTime;
			if (window.isPressed(GLFW_KEY_E)) playerYaw -= 5000.0f * deltaTime;

			const float camRotSpeed = 500.0f;
			if (window.isPressed(GLFW_KEY_LEFT)) camYaw += camRotSpeed * deltaTime;
			if (window.isPressed(GLFW_KEY_RIGHT)) camYaw -= camRotSpeed * deltaTime;
			if (window.isPressed(GLFW_KEY_UP)) camPitch += camRotSpeed * deltaTime;
			if (window.isPressed(GLFW_KEY_DOWN)) camPitch -= camRotSpeed * deltaTime;
			camPitch = glm::clamp(camPitch, -80.0f, 80.0f);

			glm::vec3 camTarget = player.pos + glm::vec3(0.0f, 0.5f, 0.0f);
			if (firstPersonView) {
				glm::vec3 eyePos = player.pos + glm::vec3(0.0f, 0.7f, 0.0f);
				camera.setPosition(eyePos);
				glm::vec3 front;
				front.x = cos(glm::radians(camYaw)) * cos(glm::radians(camPitch));
				front.y = sin(glm::radians(camPitch));
				front.z = sin(glm::radians(camYaw)) * cos(glm::radians(camPitch));
				camera.lookAt(eyePos + glm::normalize(front));
			}
			else {
				glm::vec3 baseOffset(0.0f, 1.5f, 4.0f);
				glm::mat4 rot = glm::rotate(glm::mat4(1.0f), glm::radians(camYaw), glm::vec3(0.0f, 1.0f, 0.0f));
				rot = glm::rotate(rot, glm::radians(camPitch), glm::vec3(1.0f, 0.0f, 0.0f));
				glm::vec3 camPos = camTarget + glm::vec3(rot * glm::vec4(baseOffset, 1.0f));
				camera.setPosition(camPos);
				camera.lookAt(camTarget);
			}

			static bool prevSpacePressed = false;
			bool currentSpacePressed = window.isPressed(GLFW_KEY_SPACE);
			catShootTimer += deltaTime;
			if (currentSpacePressed && !prevSpacePressed && catShootTimer >= catShootCooldown) {
				catShootTimer = 0.0f;
				glm::mat4 rot = glm::rotate(glm::mat4(1.0f), glm::radians(playerYaw), glm::vec3(0.0f, 1.0f, 0.0f));
				glm::vec3 baseDir = glm::normalize(glm::vec3(rot * glm::vec4(0.0f, 0.0f, 1.0f, 0.0f)));
				glm::vec3 rightDir = glm::normalize(glm::cross(baseDir, glm::vec3(0.0f, 1.0f, 0.0f)));
				auto spawnFurProjectile = [&](const glm::vec3& dir) {
					GameObject p; p.pos = player.pos + glm::vec3(0.0f, 0.5f, 0.0f) + dir * 0.8f; p.velocity = dir * 9.0f; p.scale = glm::vec3(0.009f); p.active = true; p.attacking = false; p.attackTimer = 2.0f; p.type = 9;
					furProjectiles.push_back(p);
					};
				spawnFurProjectile(baseDir);
				spawnFurProjectile(glm::normalize(baseDir + rightDir * 0.45f));
				spawnFurProjectile(glm::normalize(baseDir - rightDir * 0.45f));
			}
			prevSpacePressed = currentSpacePressed;

			const float ratSpeed = 2.0f;
			for (auto& e : enemies) {
				if (!e.active || e.type != 1) continue;
				float dx = player.pos.x - e.pos.x;
				float dz = player.pos.z - e.pos.z;
				float dist = std::sqrt(dx * dx + dz * dz);
				e.yaw = (atan2(dx, dz) * 180.0f / PI);
				if (dist < 2.0f) {
					glm::vec3 away = glm::normalize(glm::vec3(-dx, 0.0f, -dz));
					e.pos += away * ratSpeed * deltaTime;
					e.attacking = false;
				}
				else if (dist > 5.0f) {
					glm::vec3 toward = glm::normalize(glm::vec3(dx, 0.0f, dz));
					e.pos += toward * ratSpeed * deltaTime;
					e.attacking = false;
				}
				else {
					e.attacking = true;
					e.attackTimer -= deltaTime;
					if (e.attackTimer <= 0.0f) {
						float aimLower = 0.5f;
						float targetY = player.pos.y - aimLower;
						float dy = targetY - e.pos.y;
						glm::vec3 dir = glm::normalize(glm::vec3(dx, dy, dz));
						spawnProjectile(e.pos + glm::vec3(0.0f, 0.7f, 0.0f), dir * 6.5f);
						e.attackTimer = e.attackCooldown;
					}
				}
			}

			for (auto& p : projectiles) if (p.active) {
				p.pos += p.velocity * deltaTime;
				p.attackTimer -= deltaTime;
				float dx = player.pos.x - p.pos.x;
				float dz = player.pos.z - p.pos.z;
				float dist = std::sqrt(dx * dx + dz * dz);
				if (dist < 0.3f) { player.health -= 25.0f; p.active = false; }
				if (p.attackTimer <= 0.0f) p.active = false;
			}
			for (auto& f : furProjectiles) if (f.active) {
				f.pos += f.velocity * deltaTime;
				f.attackTimer -= deltaTime;
				for (auto& e : enemies) if (e.active && e.type == 1) {
					if (checkCollision(f, e)) { e.active = false; f.active = false; break; }
				}
				if (f.attackTimer <= 0.0f) f.active = false;
			}



			// SEWERS
			if (state == SEWERS) {
				if (playerMoved && !ratsSpawned) {
					ratsSpawnTimer += deltaTime;
					if (ratsSpawnTimer >= 2.0f) ratsSpawned = true;
				}

				if (ratsSpawned && totalSpawned < totalRatsToSpawn) {
					waveTimer += deltaTime;

					if (waveTimer >= waveInterval && currentWaveIndex < (int)ratWaves.size()) {
						int toSpawn = ratWaves[currentWaveIndex];
						if (totalSpawned + toSpawn > totalRatsToSpawn) toSpawn = totalRatsToSpawn - totalSpawned;

						float angle = glm::radians(playerYaw);
						float spawnDist = 12.0f;
						glm::vec3 spawnCenter = player.pos;
						spawnCenter.x += sin(angle) * spawnDist;
						spawnCenter.z += cos(angle) * spawnDist;

						for (int s = 0; s < toSpawn; ++s) {
							glm::vec3 finalPos = spawnCenter;
							finalPos.x += (rand() % 100 / 100.0f * 8.0f - 4.0f);
							finalPos.z += (rand() % 100 / 100.0f * 8.0f - 4.0f);

							spawnRat(finalPos);
							totalSpawned++;
						}
						currentWaveIndex++;
						waveTimer = 0.0f;
					}
				}

				int deadRats = 0;
				for (auto& e : enemies) if (!e.active && e.type == 1) deadRats++;

				if (deadRats >= totalRatsToSpawn) {
					sewerLevelComplete = true;
					exitDoor.active = true;
				}

				if (sewerLevelComplete && exitDoor.active) {
					float d = glm::distance(player.pos, exitDoor.pos);
					if (d < 5.0f && window.isPressed(GLFW_KEY_F)) {
						state = STREET;
						enemies.clear();
						player.pos = glm::vec3(0.0f, 0.5f, 5.0f);

						// Setup Street
						for (int i = 0; i < 5; i++) {
							spawnCar(glm::vec3(4.0f, 0.0f, -30.0f - (i * 20.0f)));
							spawnCar(glm::vec3(-4.0f, 0.0f, -50.0f - (i * 20.0f)));
						}

						for (int i = 0; i < 10; ++i) {
							GameObject b;
							b.pos = glm::vec3((i % 2 == 0 ? 15.0f : -15.0f), 0.0f, -i * 20.0f);
							b.scale = glm::vec3(2.0f); b.active = true; b.type = 99;
							int r = rand() % 3;
							if (r == 0) b.type = 101;
							else if (r == 1) b.type = 102;
							else b.type = 103;
							scenery.push_back(b);
						}

						buildingATarget.pos = glm::vec3(0.0f, 0.0f, -200.0f);
						buildingATarget.scale = glm::vec3(3.0f);
						buildingATarget.active = true;
					}
				}
			}
			else if (state == STREET) {
				for (auto& o : obstacles) {
					if (o.type == 4) {
						o.pos.z += o.velocity.z * deltaTime; // Move along Z
						if (o.pos.z > 20.0f) o.pos.z = -180.0f; // Loop cars
						if (checkCollision(player, o)) player.health -= 20.0f * deltaTime;
					}
				}

				float d = glm::distance(player.pos, buildingATarget.pos);
				if (d < 10.0f) {
					state = MEN_LASAGNA;
					obstacles.clear(); scenery.clear();
					player.pos = glm::vec3(0.0f, 0.5f, 0.0f);
					spawnMan(glm::vec3(-3.0f, 1.0f, -10.0f));
					spawnMan(glm::vec3(3.0f, 1.0f, -10.0f));
					GameObject l; l.pos = glm::vec3(0.0f, 0.5f, -15.0f); l.scale = glm::vec3(2.0f); l.active = true; l.type = 5; l.isHeld = false;
					items.push_back(l);
				}
			}
			else if (state == MEN_LASAGNA) {
				bool menDead = true;
				for (auto& e : enemies) if (e.active) menDead = false;

				for (auto& i : items) {
					if (i.active && i.type == 5) {
						float d = glm::distance(player.pos, i.pos);
						if (d < 2.5f) {
							i.scale -= glm::vec3(1.0f) * deltaTime;
							if (i.scale.x <= 0.1f) {
								i.active = false;
								player.health += 50.0f;
								if (player.health > 100.0f) player.health = 100.0f;
							}
						}
					}
				}

				bool lasagnaEaten = true;
				for (auto& i : items) if (i.active && i.type == 5) lasagnaEaten = false;

				if (menDead && lasagnaEaten) {
					state = KEY_PUZZLE;
					items.clear();

					for (int z = 0; z < 5; z++) {
						for (int x = -3; x < 3; x++) {
							if ((x + z) % 2 != 0) {
								GameObject box; box.pos = glm::vec3(x * 3.0f, 0.5f, -10.0f - z * 3.0f); box.scale = glm::vec3(2.0f); box.active = true; box.type = 4;
								obstacles.push_back(box);
							}
						}
					}

					GameObject k; k.pos = glm::vec3(0.0f, 0.5f, -30.0f); k.scale = glm::vec3(1.0f); k.active = true; k.type = 6; k.isHeld = false;
					items.push_back(k);
				}
			}
			else if (state == KEY_PUZZLE) {
				for (auto& i : items) {
					if (i.active && i.type == 6) {
						float d = glm::distance(player.pos, i.pos);
						if (d < 2.0f && window.isPressed(GLFW_KEY_F)) {
							i.active = false;
							state = BOSS_RESCUE;
							items.clear(); obstacles.clear();
							spawnBoss(glm::vec3(0.0f, 1.5f, -60.0f));
							GameObject k; k.pos = glm::vec3(0.0f, 0.5f, -70.0f); k.scale = glm::vec3(0.5f); k.active = true; k.type = 7; k.isHeld = false;
							items.push_back(k);
						}
					}
				}
			}
			else if (state == BOSS_RESCUE) {
				bool bossDead = true;
				for (auto& e : enemies) if (e.active && e.type == 3) {
					bossDead = false;
					glm::vec3 dir = player.pos - e.pos;
					float len = std::sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
					if (len > 0.1f) e.pos += (dir / len) * 2.0f * deltaTime;
					if (checkCollision(player, e)) player.health -= 20.0f * deltaTime;
				}
				if (bossDead) {
					for (auto& i : items) {
						if (i.active && i.type == 7 && checkCollision(player, i)) state = GAME_OVER;
					}
				}
			}

			// Collisions
			for (size_t i = 0; i < enemies.size(); ++i) for (size_t j = i + 1; j < enemies.size(); ++j) resolveOverlap(enemies[i], enemies[j]);

			if (state == SEWERS) {
				for (auto& w : sewerWalls) if (w.active) {
					resolveOverlap(player, w);
					for (auto& e : enemies) if (e.active) { if (e.type == 0) resolveOverlap(e, w); else resolveOverlap(w, e); }
				}
			}

			for (auto& o : obstacles) {
				if (o.active) resolveOverlap(player, o);
			}

			// --- RENDER 3D SCENE ---
			glm::mat4 Projection = glm::perspective(45.0f, (float)window.getWidth() / (float)window.getHeight(), 0.1f, 1000.0f);
			glm::mat4 View = glm::lookAt(camera.getCameraPosition(), camera.getCameraPosition() + camera.getCameraViewDirection(), camera.getCameraUp());

			shader.use();
			glUniform3f(glGetUniformLocation(shader.getId(), "lightColor"), sunColor.x, sunColor.y, sunColor.z);
			glUniform3f(glGetUniformLocation(shader.getId(), "lightPos"), sunPos.x, sunPos.y, sunPos.z);
			glm::vec3 camP = camera.getCameraPosition();
			glUniform3f(glGetUniformLocation(shader.getId(), "viewPos"), camP.x, camP.y, camP.z);

			auto DrawMesh = [&](Mesh& m, glm::vec3 pos, glm::vec3 s, float yaw = 0.0f, float pitch = 0.0f, float roll = 0.0f) {
				glm::mat4 Model = glm::translate(glm::mat4(1.0f), pos);
				if (yaw != 0.0f) Model = glm::rotate(Model, glm::radians(yaw), glm::vec3(0.0f, 1.0f, 0.0f));
				if (pitch != 0.0f) Model = glm::rotate(Model, glm::radians(pitch), glm::vec3(1.0f, 0.0f, 0.0f));
				if (roll != 0.0f) Model = glm::rotate(Model, glm::radians(roll), glm::vec3(0.0f, 0.0f, 1.0f));

				Model = glm::scale(Model, s);
				glm::mat4 MVP = Projection * View * Model;
				glUniformMatrix4fv(glGetUniformLocation(shader.getId(), "MVP"), 1, GL_FALSE, &MVP[0][0]);
				glUniformMatrix4fv(glGetUniformLocation(shader.getId(), "model"), 1, GL_FALSE, &Model[0][0]);
				glUniform1i(glGetUniformLocation(shader.getId(), "useTexture"), 1);
				m.draw(shader);
				};

			if (!firstPersonView) DrawMesh(catMesh, player.pos, player.scale, playerYaw);

			if (state == SEWERS) {

				DrawMesh(water, glm::vec3(0.0f, 0.5f, 0.0f), glm::vec3(30.0f, 1.0f, 200.0f),0.0f, 90.0f);

				for (auto& w : sewerWalls) if (w.active) DrawMesh(sewerWall, w.pos, w.scale, w.yaw);
				if (exitDoor.active) DrawMesh(sewerDoorMesh, exitDoor.pos, exitDoor.scale, exitDoor.yaw, exitDoor.pitch);
			}
			else if (state == STREET) {
				DrawMesh(streetGroundMesh, glm::vec3(0.0f, -0.1f, -100.0f), glm::vec3(5.0f, 1.0f, 100.0f));
				for (auto& s : scenery) {
					if (s.type == 101) DrawMesh(sewerWall, s.pos, s.scale);
					else if (s.type == 102) DrawMesh(sewerWall, s.pos, s.scale);
					else DrawMesh(sewerWall, s.pos, s.scale);
				}
				DrawMesh(cube, buildingATarget.pos, buildingATarget.scale);
			}
			else {
				DrawMesh(terrain, glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(10.0f, 1.0f, 100.0f));
			}

			for (auto& e : enemies) if (e.active) {
				if (e.type == 1) DrawMesh(ratMesh, e.pos, e.scale, e.yaw);
				else if (e.type == 3) DrawMesh(bossMesh, e.pos, e.scale);
				else DrawMesh(sphere, e.pos, e.scale);
			}
			for (auto& p : projectiles) if (p.active) DrawMesh(greenSphere, p.pos, p.scale);
			for (auto& f : furProjectiles) if (f.active) DrawMesh(furBall, f.pos, f.scale);

			for (auto& o : obstacles) if (o.active) {
				if (state == KEY_PUZZLE) DrawMesh(boxMesh, o.pos, o.scale);
				else if (state == STREET) DrawMesh(carMesh, o.pos, o.scale);
				else DrawMesh(cube, o.pos, o.scale);
			}

			for (auto& i : items) if (i.active) {
				if (i.type == 7) DrawMesh(catMesh, i.pos, i.scale);
				else if (i.type == 5) DrawMesh(lasagnaMesh, i.pos, i.scale);
				else if (i.type == 6) DrawMesh(keyMesh, i.pos, i.scale);
				else DrawMesh(cube, i.pos, i.scale);
			}
		}

		ImGui::Render();
		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

		window.update();
	}

	ImGui_ImplOpenGL3_Shutdown();
	ImGui_ImplGlfw_Shutdown();
	ImGui::DestroyContext();

	return 0;
}