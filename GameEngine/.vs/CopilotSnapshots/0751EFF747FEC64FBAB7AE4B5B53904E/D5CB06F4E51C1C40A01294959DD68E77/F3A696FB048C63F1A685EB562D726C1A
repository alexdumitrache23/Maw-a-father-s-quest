#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;
out float WaterHeight; 

uniform mat4 model;
uniform mat4 MVP;
uniform float time;

// We need to calculate not just height, but the "slope" (derivative)
// to make the lighting look real.
void calculateWave(vec2 direction, float amplitude, float frequency, float speed, vec3 currentPos, inout float height, inout vec2 slope) {
    float phase = dot(direction, currentPos.xz) * frequency + time * speed;
    
    // The height is the Sine wave
    height += amplitude * sin(phase);

    // The Slope is the Cosine (derivative of sine)
    // This tells us which way the water is tilting
    float derivative = amplitude * frequency * cos(phase);
    slope.x += direction.x * derivative;
    slope.y += direction.y * derivative;
}

void main()
{
    vec3 pos = aPos;
    float totalHeight = 0.0;
    vec2 totalSlope = vec2(0.0, 0.0);

    // --- WAVE SETTINGS ---
    // notice amplitudes (2nd number) are much smaller now (0.05 instead of 0.5)
    // This makes it look like liquid, not jagged spikes.
    calculateWave(normalize(vec2(1.0, 0.5)), 0.15, 0.8, 1.5, pos, totalHeight, totalSlope);
    calculateWave(normalize(vec2(-0.7, 0.7)), 0.10, 1.2, 1.0, pos, totalHeight, totalSlope);
    calculateWave(normalize(vec2(0.2, 1.0)), 0.05, 2.5, 2.5, pos, totalHeight, totalSlope);

    // Soften edges logic (same as before)
    float distX = min(aTexCoords.x, 1.0 - aTexCoords.x);
    float distZ = min(aTexCoords.y, 1.0 - aTexCoords.y);
    float edgeFactor = smoothstep(0.0, 0.1, min(distX, distZ));
    
    pos.y = totalHeight * edgeFactor;
    WaterHeight = pos.y; 

    FragPos = vec3(model * vec4(pos, 1.0));

    // --- RECALCULATE NORMAL ---
    // Instead of hardcoding (0,1,0), we calculate the actual tilt
    // using the slope we summed up earlier.
    vec3 newNormal = vec3(-totalSlope.x * edgeFactor, 1.0, -totalSlope.y * edgeFactor);
    Normal = normalize(mat3(transpose(inverse(model))) * newNormal);

    TexCoords = aTexCoords;
    gl_Position = MVP * vec4(pos, 1.0);
}